{"visual":{"name":"PowerBI-visuals-forcasting-TBATS","displayName":"Forecasting","guid":"PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS","visualClassName":"Visual","version":"1.0.0","description":"<span>Time series forecasting is the use of a model to predict future values based on previously observed values. Current visual implements well known exponential smoothing method for the forecasting. The prediction is based on trend and seasonality modeling. You can control the algorithm parameters and the visual attributes to suit your needs.<br/><br/><span style='font-style:italic'>Service prerequisites:</span> R-powered custom visual is used in service seamlessly<br/><br /><span style='font-style:italic'>Desktop prerequisites:</span> To run R scripts in Power BI Desktop, you must separately install R on your local computer.<br />You can download and install R for free from the <a href='https://mran.revolutionanalytics.com/download/'>Revolution Open download page</a> or the <a href='https://cran.r-project.org/bin/windows/base/'>CRAN Repository</a><br /><br /> <span style='font-style:italic'> R package dependencies(auto-installed): </span> graphics, scales, forecast, zoo, lubridate <br /><br /> <span style='font-style:italic'> Supports R versions: </span> R 3.3.1, R 3.3.0, MRO 3.3.1, MRO 3.3.0, MRO 3.2.2  <br /></span>","supportUrl":"http://community.powerbi.com/","gitHubUrl":"https://github.com/microsoft/PowerBI-visuals-forcasting-tbats"},"apiVersion":"1.4.0","author":{"name":"Microsoft","email":"pbicvsupport@microsoft.com"},"assets":{"icon":"assets/icon.png"},"externalJS":[],"style":"style/visual.less","capabilities":{"dataRoles":[{"displayName":"Date","description":"Equally spaced date values","kind":"Grouping","name":"Date"},{"displayName":"Value","description":"Numeric variable","kind":"Measure","name":"Value"}],"dataViewMappings":[{"conditions":[{"Date":{"max":1},"Value":{"max":1}}],"scriptResult":{"dataInput":{"table":{"rows":{"select":[{"for":{"in":"Date"}},{"for":{"in":"Value"}}],"dataReductionAlgorithm":{"top":{}}}}},"script":{"scriptProviderDefault":"R","scriptOutputType":"png","source":{"objectName":"rcv_script","propertyName":"source"},"provider":{"objectName":"rcv_script","propertyName":"provider"},"scriptSourceDefault":"# Copyright (c) Microsoft Corporation.  All rights reserved.\r\n\r\n# Third Party Programs. This software enables you to obtain software applications from other sources. \r\n# Those applications are offered and distributed by third parties under their own license terms.\r\n# Microsoft is not developing, distributing or licensing those applications to you, but instead, \r\n# as a convenience, enables you to use this software to obtain those applications directly from \r\n# the application providers.\r\n# By using the software, you acknowledge and agree that you are obtaining the applications directly\r\n# from the third party providers and under separate license terms, and that it is your responsibility to locate, \r\n# understand and comply with those license terms.\r\n# Microsoft grants you no license rights for third-party software or applications that is obtained using this software.\r\n\r\n#\r\n# WARNINGS:   \r\n#\r\n# CREATION DATE: 24/7/2016\r\n#\r\n# LAST UPDATE: 08/01/2017\r\n#\r\n# VERSION: 1.0.2\r\n#\r\n# R VERSION TESTED: 3.2.2\r\n# \r\n# AUTHOR: pbicvsupport@microsoft.com\r\n#\r\n# REFERENCES: http://www.exponentialsmoothing.net/\r\n\r\n\r\nfileRda = \"C:/Users/boefraty/projects/PBI/R/tempData.Rda\"\r\nif(file.exists(dirname(fileRda)))\r\n{\r\n  if(Sys.getenv(\"RSTUDIO\")!=\"\")\r\n    load(file= fileRda)\r\n  else\r\n    save(list = ls(all.names = TRUE), file=fileRda)\r\n}\r\n\r\n\r\nSys.setlocale(\"LC_ALL\",\"English\") # Internationalization \r\n\r\n############ User Parameters #########\r\n\r\n##PBI_PARAM: Should warnings text be displayed?\r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nshowWarnings=TRUE\r\n\r\n\r\n\r\n\r\n##PBI_PARAM: Show cumulative value inside shown period (actual + predicted)?\r\n#Type:logical, Default:FALSE, Range:NA, PossibleValues:NA, Remarks: NA\r\nshowInfoCumSum = FALSE\r\nif(exists(\"settings_info_params_showInfoCumSum\"))\r\n  showInfoCumSum = settings_info_params_showInfoCumSum\r\n\r\n##PBI_PARAM: Show TBATS method selected\r\n#Type:logical, Default:FALSE, Range:NA, PossibleValues:NA, Remarks: NA\r\nshowInfoMethodTBATS = FALSE\r\nif(exists(\"settings_info_params_showInfoMethodTBATS\"))\r\n  showInfoMethodTBATS = settings_info_params_showInfoMethodTBATS\r\n\r\n\r\n##PBI_PARAM: Show information criterion of the found model\r\n#Type:logical, Default:FALSE, Range:NA, PossibleValues:NA, Remarks: NA\r\nshowInfoCriterion = FALSE\r\nif(exists(\"settings_info_params_showInfoCriterion\"))\r\n  showInfoCriterion = settings_info_params_showInfoCriterion\r\n\r\n\r\nshowInfo=any(c(showInfoCumSum,showInfoCriterion, showInfoMethodTBATS))\r\n\r\n##PBI_PARAM: Forecast length\r\n#Type:integer, Default:NULL, Range:NA, PossibleValues:NA, Remarks: NULL means choose forecast length automatically\r\nforecastLength=500\r\nif(exists(\"settings_forecastPlot_params_forecastLength\"))\r\n{\r\n  forecastLength = as.numeric(settings_forecastPlot_params_forecastLength)\r\n  if(is.na(forecastLength))\r\n    forecastLength = 10\r\n  forecastLength = round(max(min(forecastLength,1e+6),1))\r\n}\r\n\r\n##PBI_PARAM: Number of data points in smaller season period\r\n#Type:integer, Default:NULL, Range:NA, PossibleValues:NA, Remarks: NULL means choose forecast length automatically\r\nfreq1=1\r\nif(exists(\"settings_forecastPlot_params_freq1\"))\r\n{\r\n  freq1 = as.numeric(settings_forecastPlot_params_freq1)\r\n  if(is.na(freq1))\r\n    freq1 = 1\r\n  freq1 = round(max(min(freq1,1e+6),1))\r\n}\r\n\r\n##PBI_PARAM: Number of data points in larger season period\r\n#Type:integer, Default:NULL, Range:NA, PossibleValues:NA, Remarks: NULL means choose forecast length automatically\r\nfreq2=1\r\nif(exists(\"settings_forecastPlot_params_freq2\"))\r\n{\r\n  freq2 = as.numeric(settings_forecastPlot_params_freq2)\r\n  if(is.na(freq2))\r\n    freq2 = 1\r\n  freq2 = round(max(min(freq2,1e+6),1))\r\n}\r\n# freq1 = 96 \r\n# freq2 = 672 \r\n\r\n\r\n\r\n\r\nconfInterval1 = 0.5\r\nif (exists(\"settings_conf_params_confInterval1\")) \r\n{ \r\n  confInterval1 = as.numeric(settings_conf_params_confInterval1)\r\n  if(is.na(confInterval1))\r\n    confInterval1 = 0.5\r\n}\r\nconfInterval2 = 0.995\r\nif (exists(\"settings_conf_params_confInterval2\")) \r\n{ \r\n  confInterval2 = as.numeric(settings_conf_params_confInterval2)\r\n  if(is.na(confInterval2))\r\n    confInterval1 = 0.995\r\n}\r\n\r\nif(confInterval1>confInterval2)\r\n{\r\n  temp = confInterval2\r\n  confInterval2 = confInterval1\r\n  confInterval1 = temp\r\n}\r\n\r\nlowerConfInterval = confInterval1\r\nupperConfInterval = confInterval2\r\n\r\nshowFromTo = \"mday\"# \r\nif(exists(\"settings_graph_params_showFromTo\"))\r\n  showFromTo = settings_graph_params_showFromTo\r\n\r\npossibleFromTo = c('all','hour','mday','week','mon','year')\r\n\r\nif(!(showFromTo %in% possibleFromTo))\r\n  showFromTo = possibleFromTo[1]\r\n\r\nshowInPlotFitted = FALSE\r\nif(exists(\"settings_graph_params_showInPlotFitted\"))\r\n  showInPlotFitted = settings_graph_params_showInPlotFitted\r\n\r\n\r\nvaluesNonNegative = FALSE\r\nif(exists(\"settings_additional_params_valuesNonNegative\"))\r\n  valuesNonNegative = settings_additional_params_valuesNonNegative\r\n\r\nalgModeFast = FALSE\r\nif(exists(\"settings_additional_params_algModeFast\"))\r\n  algModeFast = settings_additional_params_algModeFast\r\n\r\n\r\nuserDateFormat = \"auto\" # \r\n\r\n\r\n\r\n###############Library Declarations###############\r\n\r\nlibraryRequireInstall = function(packageName, ...)\r\n{\r\n  if(!require(packageName, character.only = TRUE)) \r\n    warning(paste(\"*** The package: '\", packageName, \"' was not installed ***\",sep=\"\"))\r\n}\r\n\r\n#ets\r\nlibraryRequireInstall(\"graphics\")\r\nlibraryRequireInstall(\"scales\")\r\nlibraryRequireInstall(\"forecast\")\r\nlibraryRequireInstall(\"zoo\")\r\nlibraryRequireInstall(\"ggplot2\")\r\nlibraryRequireInstall(\"lubridate\")\r\n\r\n###############Internal parameters definitions#################\r\n\r\n#PBI_PARAM Minimal number of points\r\n#Type:integer, Default:7, Range:[0,], PossibleValues:NA, Remarks: NA\r\nminPoints = 7\r\n\r\n##PBI_PARAM Color of time series line\r\n#Type:string, Default:\"orange\", Range:NA, PossibleValues:\"orange\",\"blue\",\"green\",\"black\"\r\npointsCol = \"orange\"\r\nif(exists(\"settings_graph_params_dataCol\"))\r\n  pointsCol = settings_graph_params_dataCol\r\n\r\n##PBI_PARAM Color of forecast line\r\n#Type:string, Default:\"red\", Range:NA, PossibleValues:\"red\",\"blue\",\"green\",\"black\"\r\nforecastCol = \"red\"\r\nif(exists(\"settings_graph_params_forecastCol\"))\r\n  forecastCol = settings_graph_params_forecastCol\r\n\r\n#PBI_PARAM Transparency of scatterplot points\r\n#Type:numeric, Default:0.4, Range:[0,1], PossibleValues:NA, Remarks: NA\r\ntransparency = 1\r\nif(exists(\"settings_graph_params_percentile\"))\r\n  transparency = as.numeric(settings_graph_params_percentile)/100\r\n\r\n#PBI_PARAM Shaded band for confidence interval\r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nfillConfidenceLevels=TRUE\r\n\r\n#PBI_PARAM damping\r\n#Type:logical, Default: NULL, Remarks: NULL selects damped or undamped trend depending on which fits better\r\ndamped = NULL\r\nif(exists(\"settings_forecastPlot_params_dampingType\"))\r\n{\r\n  damped = as.logical(settings_forecastPlot_params_dampingType)\r\n  if(is.na(damped))\r\n    damped=NULL\r\n}\r\n\r\n#PBI_PARAM Size of points on the plot\r\n#Type:numeric, Default: 1 , Range:[0.1,5], PossibleValues:NA, Remarks: NA\r\npointCex = 1\r\nif(exists(\"settings_graph_params_weight\"))\r\n  pointCex = as.numeric(settings_graph_params_weight)/10\r\n\r\n#PBI_PARAM Size of subtitle on the plot\r\n#Type:numeric, Default: 0.75 , Range:[0.1,5], PossibleValues:NA, Remarks: NA\r\ncexSub = 0.75\r\nif(exists(\"settings_info_params_textSize\"))\r\n  cexSub = as.numeric(settings_info_params_textSize)/12\r\n\r\n\r\n\r\n#PBI_PARAM Size of labels on axes\r\n#Type:numeric , Default:12, Range:NA, PossibleValues:[1,50], Remarks: NA\r\nsizeLabel = 12\r\n\r\n#PBI_PARAM Size of warnings font\r\n#Type:numeric , Default:cexSub*12, Range:NA, PossibleValues:[1,50], Remarks: NA\r\nsizeWarn = cexSub*12\r\n\r\n#PBI_PARAM Size of ticks on axes \r\nsizeTicks = 8\r\n\r\n#PBI_PARAM opacity of conf interval color\r\ntransparencyConfInterval = 0.3 \r\n\r\n\r\n\r\n###############Internal functions definitions#################\r\n\r\n# tiny function to deal with verl long strings on plot\r\ncutStr2Show = function(strText, strCex = 0.8, abbrTo = 100, isH = TRUE, maxChar = 3, partAvailable = 1)\r\n{\r\n  # partAvailable, wich portion of window is available, in [0,1]\r\n  if(is.null(strText))\r\n    return (NULL)\r\n  \r\n  SCL = 0.075*strCex/0.8\r\n  pardin = par()$din\r\n  gStand = partAvailable*(isH*pardin[1]+(1-isH)*pardin[2]) /SCL\r\n  \r\n  # if very very long abbreviate\r\n  if(nchar(strText)>abbrTo && nchar(strText)> 1)\r\n    strText = abbreviate(strText, abbrTo)\r\n  \r\n  # if looooooong convert to lo...\r\n  if(nchar(strText)>round(gStand) && nchar(strText)> 1)\r\n    strText = paste(substring(strText,1,floor(gStand)),\"...\",sep=\"\")\r\n  \r\n  # if shorter than maxChar remove \r\n  if(gStand<=maxChar)\r\n    strText = NULL\r\n  \r\n  return(strText) \r\n}\r\n\r\n\r\n# verify if \"perSeason\" is good for \"frequency\" parameter\r\nfreqSeason = function(seasons,perSeason)\r\n{\r\n  if((seasons > 5 && perSeason > 3) || (seasons>2 && perSeason > 7))\r\n    return (perSeason)\r\n  \r\n  return(1)\r\n}\r\n\r\n# find frequency using the dates, targetS is a \"recommended\" seasonality \r\nfindFreq = function(dates, targetS = \"Automatic\")\r\n{\r\n  freq = 1\r\n  N = length(dates)\r\n  nnn = c(\"Minute\",\"Hour\", \"Day\", \"Week\", \"Month\", \"Quater\", \"Year\")\r\n  seasons = rep(NaN,7)\r\n  names(seasons) = nnn\r\n  perSeason = seasons\r\n  \r\n  seasons[\"Day\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"days\"))\r\n  seasons[\"Hour\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"hours\"))\r\n  seasons[\"Minute\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"mins\"))\r\n  seasons[\"Week\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"weeks\"))\r\n  seasons[\"Month\"] = seasons[\"Day\"]/30\r\n  seasons[\"Year\"] = seasons[\"Day\"]/365.25\r\n  seasons[\"Quater\"] = seasons[\"Year\"]*4\r\n  \r\n  perSeason = N/seasons\r\n  \r\n  if(targetS!=\"Automatic\") # target \r\n    freq = perSeason[targetS]\r\n  \r\n  if(freq < 2 || round(freq)>24) # if TRUE, target season factor is not good \r\n    freq = 1\r\n  \r\n  for( s in rev(nnn)) # check year --> Quater --> etc\r\n    if(freq==1 || round(freq)>24)\r\n      freq = freqSeason(seasons[s],perSeason[s])\r\n  \r\n  \r\n  if(round(freq)>24) # limit of exp smoothing R implementation\r\n    freq = 1\r\n  \r\n  return(freq)\r\n}\r\n\r\n\r\n\r\n# Find number of ticks on X axis \r\nFindTicksNum = function(n,f)\r\n{\r\n  tn = 10 # default minimum\r\n  D = 2 # tick/inch\r\n  numCircles = n/f\r\n  xSize = par()$din[1]\r\n  tn = max(round(xSize*D),tn)\r\n  return(tn) \r\n}\r\n\r\n#format labels on X-axis automatically \r\nflexFormat = function(dates, orig_dates, freq = 1, myformat = NULL)\r\n{\r\n  \r\n  days=(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"days\"))\r\n  months = days/30\r\n  years = days/365.25\r\n  \r\n  \r\n  constHour = length(unique(orig_dates$hour))==1\r\n  constMin = length(unique(orig_dates$min))==1\r\n  constSec = length(unique(orig_dates$sec))==1\r\n  constMon = length(unique(orig_dates$mon))==1\r\n  \r\n  timeChange = any(!constHour,!constMin,!constSec)\r\n  \r\n  if(is.null(myformat))\r\n  {\r\n    if(years > 10){\r\n      if(constMon)\r\n      {\r\n        myformat = \"%Y\" #many years => only year :2001\r\n      }else{\r\n        myformat = \"%m/%y\" #many years + months :12/01\r\n      }\r\n    }else{\r\n      if(years > 1 && N < 50){\r\n        myformat = \"%b %d, %Y\" #several years, few samples:Jan 01, 2010\r\n      }else{\r\n        if(years > 1){\r\n          myformat = \"%m/%d/%y\" #several years, many samples: 01/20/10\r\n        }else{\r\n          if(years <= 1 && !timeChange)\r\n            myformat = \"%b %d\" #1 year,no time: Jan 01\r\n        }  \r\n      }\r\n    }\r\n  }\r\n  if(is.null(myformat) && timeChange)\r\n    if(years>1){\r\n      myformat = \"%m/%d/%y %H:%M\" # 01/20/10 12:00\r\n    }else{\r\n      if(days>1){\r\n        myformat = \"%b %d, %H:%M\" # Jan 01 12:00\r\n      }else{\r\n        if(days<=1){\r\n          myformat = \"%H:%M\" # Jan 01 12:00\r\n        }  \r\n      }\r\n    }\r\n  if(!is.null(myformat)){\r\n    if(myformat == \"%Y,Q%q\")\r\n      dates = as.yearqtr(dates)\r\n    dates1= format(dates,  myformat)\r\n  }else{\r\n    dates1 = as.character(1:length(dates)) # just id \r\n  }\r\n  return(dates1)\r\n}\r\n\r\njoinFreq = function (f1 ,f2 = NULL)\r\n{\r\n  if(is.null(f1) || is.na(f1) || f1 < 1)\r\n    f1 = NULL\r\n  if(is.null(f2) || is.na(f2) || f2 < 1)\r\n    f2 = NULL\r\n  \r\n  f = unique(c(f1,f2))\r\n  if(is.null(f) || is.na(f) || f < 1)\r\n    f = 1\r\n  \r\n  return(f)\r\n  \r\n}\r\n\r\n\r\nindexShowFromTo = function(showFromTo,datesActual, datesAll)\r\n{\r\n  Lall = length(datesAll)\r\n  Lactual = length(datesActual)\r\n  \r\n  if(showFromTo == \"all\")\r\n  {\r\n  frto = c(1,Lall)\r\n  return(frto)\r\n  }\r\n  \r\n  if(showFromTo == \"hour\")\r\n  {\r\n    v = datesAll$hour\r\n    target = v[Lactual]\r\n  }\r\n  \r\n  if(showFromTo == \"mday\")\r\n  {\r\n    v = datesAll$mday\r\n    target = v[Lactual]\r\n  }\r\n  if(showFromTo == \"mon\")\r\n  {\r\n    v = datesAll$mon\r\n    target = v[Lactual]\r\n  }\r\n  if(showFromTo == \"year\")\r\n  {\r\n    v = datesAll$year\r\n    target = v[Lactual]\r\n  }\r\n  \r\n  if(showFromTo == \"week\")\r\n  {\r\n    \r\n    v = lubridate::week(datesAll)\r\n    target = v[Lactual]\r\n  }\r\n  \r\n  \r\n  fr = Lactual\r\n  # go backward \r\n  for (i in rev(1:Lactual))\r\n  {\r\n    if(v[i] == target)\r\n      fr = i\r\n    else\r\n      break;\r\n  }\r\n  \r\n  to = Lactual\r\n  # go forward \r\n  for (i in (Lactual:Lall))\r\n  {\r\n    if(v[i] == target)\r\n      to = i\r\n    else\r\n      break;\r\n  }\r\n  frto = c(fr,to)\r\n  \r\n  return(frto)\r\n  \r\n}\r\n\r\n\r\n###############Upfront input correctness validations (where possible)#################\r\n\r\npbiWarning = NULL\r\n\r\n\r\n\r\nif(!exists(\"Date\") || !exists(\"Value\"))\r\n{\r\n  dataset=data.frame()\r\n  pbiWarning  = cutStr2Show(\"Both 'Date' and 'Value' fields are required.\", strCex = 0.85)\r\n  timeSeries=ts()\r\n  showWarnings=TRUE\r\n}else{\r\n  dataset= cbind(Date,Value)\r\n  dataset<-dataset[complete.cases(dataset),] #remove corrupted rows\r\n  labTime = \"Time\"\r\n  labValue=names(dataset)[ncol(dataset)]\r\n  \r\n  # dataset = dataset[-nrow(dataset),]\r\n  # dataset = dataset[-nrow(dataset),]\r\n  # dataset = dataset[-nrow(dataset),]\r\n  \r\n  N=nrow(dataset)\r\n  \r\n  if(N==0 && exists(\"Date\") && nrow(Date)>0 &&  exists(\"Value\")){\r\n    pbiWarning1  = cutStr2Show(\"Wrong date type. Only 'Date', 'Time', 'Date/Time' are allowed without hierarchy\", strCex = 0.85)\r\n    pbiWarning = paste(pbiWarning1, pbiWarning, sep =\"\\n\")\r\n    timeSeries=ts()\r\n    showWarnings=TRUE\r\n  }else {\r\n    \r\n    dataset = dataset[order(dataset[,1]),]\r\n    parsed_dates=strptime(dataset[,1],\"%Y-%m-%dT%H:%M:%S\",tz=\"UTC\")\r\n    labTime = names(Date)[1]\r\n    \r\n    if((any(is.na(parsed_dates))))\r\n    {\r\n      pbiWarning1  = cutStr2Show(\"Wrong or corrupted 'Date'.\", strCex = 0.85)\r\n      pbiWarning2  = cutStr2Show(\"Only 'Date', 'Time', 'Date/Time' types are allowed without hierarchy\", strCex = 0.85)\r\n      pbiWarning = paste(pbiWarning1, pbiWarning2, pbiWarning, sep =\"\\n\")\r\n      timeSeries=ts()\r\n      showWarnings=TRUE\r\n    }\r\n    else\r\n    {\r\n      \r\n      interval = difftime(parsed_dates[length(parsed_dates)],parsed_dates[1])/(length(parsed_dates)-1) # force equal spacing \r\n      myFreq = findFreq(parsed_dates, targetS = 1)\r\n      timeSeries=ts(data = dataset[,2], start=1, frequency = round(myFreq))\r\n    }\r\n  }\r\n}\r\n##############Main Visualization script###########\r\n\r\npbiInfo = NULL\r\n\r\n\r\nif(length(timeSeries)>=minPoints) {\r\n  \r\n\r\n  \r\n  # compute part of dates to show\r\n  actTimes = as.POSIXlt(seq(from=parsed_dates[1], to = parsed_dates[length(parsed_dates)], length.out = length(parsed_dates)))\r\n  allTimes = as.POSIXlt(seq(from=parsed_dates[1], to = (parsed_dates[1]+interval*(length(parsed_dates)+forecastLength)), length.out = length(parsed_dates)+forecastLength))\r\n  fFromTo = indexShowFromTo(showFromTo,actTimes, allTimes)\r\n  myInclude = length(actTimes) - fFromTo[1]\r\n  myForecastLength = min(forecastLength,fFromTo[2] - length(actTimes)) + 1\r\n  \r\n  if(myForecastLength == 0)\r\n  {\r\n    actTimes1 = allTimes[1:(length(actTimes)+1)]\r\n    fFromTo = indexShowFromTo(showFromTo,actTimes1, allTimes)\r\n    myInclude = 1\r\n    myForecastLength = min(forecastLength,fFromTo[2] - length(actTimes)) + 1\r\n  }\r\n  \r\n  numPo = myInclude + myForecastLength\r\n  \r\n   d <- freq1 #daily seasonality\r\n   w <- freq2 #weekly seasonality\r\n   \r\n   startC <- 1/freq2 #starting point for axis\r\n   finishC <- numPo/freq2 #end point for axis\r\n   \r\n   \r\n   freqs = joinFreq(freq1,freq2)\r\n   \r\n   #calculate how many periods to forecast assuming the first row starts a new day\r\n   l <- N # length(dataset[,2]) #how many intervals in the data\r\n   a <- myInclude #the number of rows to include from actuals\r\n   f <- myForecastLength #number of periods to forecast \r\n   y <- msts(dataset[,2], seasonal.periods=c(d, w), start= (-N+myInclude)/freq2 )#+d/w)\r\n   \r\n  \r\n   timeSeries=msts(data = dataset[,2], seasonal.periods=freqs, start= -l/w +a/w)\r\n   timeSeries = y\r\n   \r\n\r\n   \r\n   if(algModeFast)\r\n     fit <- tbats(timeSeries, use.box.cox = FALSE, use.trend = FALSE, use.damped.trend = FALSE,\r\n                  use.arma.errors = FALSE, max.p= 2, max.q = 2,\r\n                  max.P = 1, max.Q = 1, max.order= 3, max.d = 1, max.D = 0 )\r\n    else\r\n      fit <- tbats(timeSeries) \r\n   \r\n   # fit <- tbats(timeSeries, use.box.cox=FALSE, use.trend= TRUE, use.damped.trend = FALSE,\r\n   #              use.arma.errors=TRUE, use.parallel= TRUE,\r\n   #              num.cores= NULL, bc.lower=0, bc.upper=1, biasadj=FALSE)\r\n   # \r\n   \r\n   if(lowerConfInterval==0)\r\n     lowerConfInterval = NULL; \r\n   \r\n  if (is.null(forecastLength))\r\n    prediction = forecast(fit, level=c(lowerConfInterval,upperConfInterval))\r\n  else\r\n    prediction = forecast(fit, level=c(lowerConfInterval,upperConfInterval), h=myForecastLength)\r\n  \r\n  # lastValue = tail(prediction$x,1)\r\n  # \r\n  # prediction$mean=ts(c(lastValue,prediction$mean), \r\n  #                    frequency = frequency(prediction$mean), \r\n  #                    end=end(prediction$mean))\r\n  # \r\n  # prediction$upper=ts(rbind(c(lastValue,lastValue),prediction$upper), \r\n  #                     frequency = frequency(prediction$upper), \r\n  #                     end=end(prediction$upper))\r\n  # \r\n  # prediction$lower=ts(rbind(c(lastValue,lastValue),prediction$lower), \r\n  #                     frequency = frequency(prediction$lower), \r\n  #                     end=end(prediction$lower))\r\n  \r\n   \r\n   if(valuesNonNegative)\r\n   {\r\n     prediction$mean[prediction$mean < 0] = 0\r\n     prediction$upper[prediction$upper<0] = 0\r\n     prediction$lower[prediction$lower<0] = 0\r\n     prediction$fitted[prediction$fitted<0] = 0\r\n     \r\n   }\r\n     \r\n     \r\n   myCumSum = sum(prediction$mean) + sum(dataset[fFromTo[1]:N,2])\r\n   \r\n   \r\n  if(showInfo && showInfoMethodTBATS)\r\n    pbiInfo=paste(pbiInfo,\"\", prediction$method, \". \",sep=\"\")\r\n  \r\n   if(showInfoCumSum)\r\n     pbiInfo=paste(pbiInfo, \"Cumulative: \", format(myCumSum, digits=3, nsmall=2),\". \", sep=\"\")\r\n   \r\n   if(showInfoCriterion)\r\n     pbiInfo=paste(pbiInfo, \"AIC: \", format(fit$AIC, digits=3, nsmall=2), \". \", sep=\"\")\r\n  \r\n  labTime = cutStr2Show(labTime, strCex =1.1, isH = TRUE)\r\n  labValue = cutStr2Show(labValue, strCex =1.1, isH = FALSE)\r\n  \r\n \r\n  \r\n  \r\n  plot.forecast(prediction, lwd=pointCex, col=alpha(pointsCol,transparency), fcol=alpha(forecastCol,transparency), flwd = pointCex, shaded=fillConfidenceLevels, \r\n                main = \"\", sub = pbiInfo, col.sub = \"gray50\", cex.sub = cexSub, xlab = labTime, ylab = labValue, xaxt = \"n\", include = myInclude)\r\n  \r\n  if(1)\r\n  {\r\n  NpF = myInclude + myForecastLength\r\n # freq = frequency(timeSeries)\r\n  \r\n  \r\n  #format  x_with_f\r\n  numTicks = FindTicksNum(NpF,max(freqs)) # find based on plot size\r\n  numTicks = min(numTicks, NpF)\r\n  \r\n  fromDate = parsed_dates[length(parsed_dates) - myInclude ]\r\n  toDate =  parsed_dates[1]+interval*(length(parsed_dates)+myForecastLength - 1)\r\n  \r\n # x_with_f = as.POSIXlt(seq(from=fromDate, to = toDate, length.out = numTicks))\r\n  x_with_f_exist = as.POSIXlt(seq(from=fromDate, to = toDate, by = interval))\r\n  iii = unique(round(seq(from = 1, to = length(x_with_f_exist), length.out = numTicks)))\r\n  x_with_f = x_with_f_exist[iii]\r\n  \r\n  #TODO: find closest x_with_f_exist in x_with_f\r\n  \r\n  x_with_forcast_formatted = flexFormat(dates = x_with_f, orig_dates = parsed_dates, freq = max(freqs))\r\n  \r\n  correction = (NpF-1)/(numTicks-1) # needed due to subsampling of ticks\r\n  axis(1, at = 0+correction*((0:(numTicks-1))/max(freqs)), labels = x_with_forcast_formatted)\r\n  }\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n} else{ #empty plot\r\n  plot.new()\r\n  showWarnings = TRUE\r\n  pbiWarning<-paste(pbiWarning, \"Not enough data points\", sep=\"\\n\")\r\n}\r\n\r\n#add warning as subtitle\r\nif(showWarnings)\r\n  title(main=NULL, sub=pbiWarning,outer=FALSE, col.sub = \"gray50\", cex.sub=cexSub)\r\n\r\n#remove(\"dataset\")"}}}],"objects":{"rcv_script":{"properties":{"provider":{"type":{"text":true}},"source":{"type":{"scripting":{"source":true}}}}},"settings_forecastPlot_params":{"displayName":"Forecasting settings","description":"Basic decomposition models are:  1. Additive: x[t] = Trend + Seasonal + Random, 2. Multiplicative:  x[t] = Trend * Seasonal * Random. Hybrid models are allowed. Any forbiden model combination will be replaced by `Automatic`","properties":{"forecastLength":{"displayName":"Forecast length","description":"Number of data points to predict","type":{"numeric":true}},"freq1":{"displayName":"Seasonal period #1","description":"Number of data points in smaller season period","type":{"numeric":true}},"freq2":{"displayName":"Seasonal period #2","description":"Number of data points in larger season period","type":{"numeric":true}}}},"settings_conf_params":{"displayName":"Confidence intervals","properties":{"confInterval1":{"displayName":"Confidence level","description":"Select first confidence interval","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"0.2","value":"0.2"},{"displayName":"0.4","value":"0.4"},{"displayName":"0.5","value":"0.5"},{"displayName":"0.75","value":"0.75"},{"displayName":"0.8","value":"0.8"},{"displayName":"0.9","value":"0.9"},{"displayName":"0.95","value":"0.95"},{"displayName":"0.975","value":"0.975"},{"displayName":"0.98","value":"0.98"},{"displayName":"0.99","value":"0.99"},{"displayName":"0.995","value":"0.995"},{"displayName":"0.999","value":"0.999"}]}},"confInterval2":{"displayName":"Confidence level #2","description":"Select additional confidence interval","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"0.2","value":"0.2"},{"displayName":"0.4","value":"0.4"},{"displayName":"0.5","value":"0.5"},{"displayName":"0.75","value":"0.75"},{"displayName":"0.8","value":"0.8"},{"displayName":"0.9","value":"0.9"},{"displayName":"0.95","value":"0.95"},{"displayName":"0.975","value":"0.975"},{"displayName":"0.98","value":"0.98"},{"displayName":"0.99","value":"0.99"},{"displayName":"0.995","value":"0.995"},{"displayName":"0.999","value":"0.999"}]}}}},"settings_graph_params":{"displayName":"Graphical parameters","properties":{"dataCol":{"displayName":"History data color","type":{"fill":{"solid":{"color":true}}}},"forecastCol":{"displayName":"Forecast data color","type":{"fill":{"solid":{"color":true}}}},"percentile":{"displayName":"Opacity","type":{"numeric":true}},"weight":{"displayName":"Line width","type":{"numeric":true}},"showFromTo":{"displayName":"Show subset of dates","description":"Show subset of dates","type":{"enumeration":[{"displayName":"all","value":"all"},{"displayName":"last hour","value":"hour"},{"displayName":"last day","value":"mday"},{"displayName":"last week","value":"week"},{"displayName":"last month","value":"mon"},{"displayName":"last year","value":"year"}]}},"showInPlotFitted":{"displayName":"Show fitted values","description":"Show fitted values","type":{"bool":true}}}},"settings_additional_params":{"displayName":"Advanced parameters","properties":{"algModeFast":{"displayName":"Fast execution mode","description":"Relatively fast non-accurate execution mode","type":{"bool":true}},"valuesNonNegative":{"displayName":"Positive data values","description":"Set negative prediction to zero","type":{"bool":true}}}},"settings_info_params":{"displayName":"Info parameters","properties":{"showInfoMethodTBATS":{"displayName":"Show TBATS method selected","type":{"bool":true}},"showInfoCumSum":{"displayName":"Show cumulative value","description":"Show cumulative value inside shown period (actual + predicted)","type":{"bool":true}},"showInfoCriterion":{"displayName":"Show information criterion","description":"Show information criterion of the found model","type":{"bool":true}},"textSize":{"displayName":"Font size","description":"Font size used to show information","type":{"numeric":true}}}}},"suppressDefaultTitle":true},"dependencies":{"cranPackages":[{"name":"zoo","displayName":"zoo: S3 Infrastructure for Regular and Irregular Time Series","url":"https://cran.r-project.org/web/packages/zoo/index.html"},{"name":"scales","displayName":"scales: Scale Functions for Visualization","url":"https://cran.r-project.org/web/packages/scales/index.html"},{"name":"reshape2","displayName":"reshape2: Flexibly Reshape Data: A Reboot of the Reshape Package","url":"https://cran.r-project.org/web/packages/reshape2/index.html"},{"name":"forecast","displayName":"forecast: Forecasting Functions for Time Series and Linear Models","url":"https://cran.r-project.org/web/packages/forecast/index.html"},{"name":"lubridate","displayName":"lubridate: Make Dealing with Dates a Little Easier","url":"https://cran.r-project.org/web/packages/lubridate/index.html"}]},"stringResources":{},"content":{"js":"var powerbi;!function(t){!function(t){!function(t){!function(t){function e(t,e,a,s){if(t){var i=t[e];if(i){var n=i[a];if(void 0!==n)return n}}return s}function a(t,e,a,s,i,n){if(t){var o=t[e];if(o){var r=o[a];if(r<i)return i;if(r>n)return n;if(void 0!==r)return r}}return s}function s(t,e,a,s,i,n){if(t){var o=t[e];if(o){var r=o[a];if(void 0!==r)return r>n?n:r<i?i:r}}return s}function i(t,e,a,s,i,n){return n&&e==a&&1==i?s:n&&e!=a&&0==i?s:t}function n(t,e){return\"auto\"!=e?\"None\":\"auto\"==e&&\"None\"==t?\"fast\":t}function o(t,e,a){return t<e?e:t>a?a:t}function r(t,e,a,s,i){var n=t.objects;if(n){var o=n[e];if(o){var r=o[a];if(r){var _=r[s];if(void 0!==_)return _}}}return i}t.getValue=e,t.getValueMinMax=a,t.getValueNumberMinMax=s,t.ifStringReturnString=i,t.ifStringReturnStringClustersMethod=n,t.inMinMax=o,t.getCategoricalObjectValue=r}(t.PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS||(t.PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS={}))}(t.visual||(t.visual={}))}(t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){!function(t){!function(t){!function(t){var e=function(){function e(t){this.imageDiv=document.createElement(\"div\"),this.imageDiv.className=\"rcv_autoScaleImageContainer\",t.element.appendChild(this.imageDiv),this.imageElement=document.createElement(\"img\"),this.imageElement.className=\"rcv_autoScaleImage\",this.imageDiv.appendChild(this.imageElement),this.settings_forecastPlot_params={forecastLength:10,freq1:1,freq2:1},this.settings_conf_params={confInterval1:\"0.5\",confInterval2:\"0.995\"},this.settings_graph_params={dataCol:\"orange\",forecastCol:\"red\",percentile:40,weight:10,showFromTo:\"all\",showInPlotFitted:!1},this.settings_additional_params={valuesNonNegative:!1,algModeFast:!1},this.settings_info_params={textSize:10,showInfoMethodTBATS:!1,showInfoCumSum:!1,showInfoCriterion:!1}}return e.prototype.update=function(e){var a=e.dataViews;if(a&&0!==a.length){var s=a[0];if(s&&s.metadata){this.settings_forecastPlot_params={forecastLength:t.getValue(s.metadata.objects,\"settings_forecastPlot_params\",\"forecastLength\",10),freq1:t.getValue(s.metadata.objects,\"settings_forecastPlot_params\",\"freq1\",1),freq2:t.getValue(s.metadata.objects,\"settings_forecastPlot_params\",\"freq2\",1)},this.settings_conf_params={confInterval1:t.getValue(s.metadata.objects,\"settings_conf_params\",\"confInterval1\",\"0.5\"),confInterval2:t.getValue(s.metadata.objects,\"settings_conf_params\",\"confInterval2\",\"0.995\")},this.settings_graph_params={dataCol:t.getValue(s.metadata.objects,\"settings_graph_params\",\"dataCol\",\"orange\"),forecastCol:t.getValue(s.metadata.objects,\"settings_graph_params\",\"forecastCol\",\"red\"),percentile:t.getValue(s.metadata.objects,\"settings_graph_params\",\"percentile\",40),weight:t.getValue(s.metadata.objects,\"settings_graph_params\",\"weight\",10),showFromTo:t.getValue(s.metadata.objects,\"settings_graph_params\",\"showFromTo\",\"all\"),showInPlotFitted:t.getValue(s.metadata.objects,\"settings_graph_params\",\"showInPlotFitted\",!1)},this.settings_additional_params={algModeFast:t.getValue(s.metadata.objects,\"settings_additional_params\",\"algModeFast\",!1),valuesNonNegative:t.getValue(s.metadata.objects,\"settings_additional_params\",\"valuesNonNegative\",!1)},this.settings_info_params={textSize:t.getValue(s.metadata.objects,\"settings_info_params\",\"textSize\",10),showInfoCriterion:t.getValue(s.metadata.objects,\"settings_info_params\",\"showInfoCriterion\",!1),showInfoCumSum:t.getValue(s.metadata.objects,\"settings_info_params\",\"showInfoCumSum\",!1),showInfoMethodTBATS:t.getValue(s.metadata.objects,\"settings_info_params\",\"showInfoMethodTBATS\",!1)};var i=null;s.scriptResult&&s.scriptResult.payloadBase64&&(i=\"data:image/png;base64,\"+s.scriptResult.payloadBase64),this.imageElement.src=i||null,this.onResizing(e.viewport)}}},e.prototype.onResizing=function(t){this.imageDiv.style.height=t.height+\"px\",this.imageDiv.style.width=t.width+\"px\"},e.prototype.enumerateObjectInstances=function(e){var a=e.objectName,s=[];switch(a){case\"settings_forecastPlot_params\":s.push({objectName:a,properties:{forecastLength:Math.round(t.inMinMax(this.settings_forecastPlot_params.forecastLength,1,1e6)),freq1:Math.round(t.inMinMax(this.settings_forecastPlot_params.freq1,1,1e6)),freq2:Math.round(t.inMinMax(this.settings_forecastPlot_params.freq2,1,1e6))},selector:null});break;case\"settings_conf_params\":s.push({objectName:a,properties:{confInterval1:this.settings_conf_params.confInterval1,confInterval2:this.settings_conf_params.confInterval2},selector:null});break;case\"settings_graph_params\":s.push({objectName:a,properties:{dataCol:this.settings_graph_params.dataCol,forecastCol:this.settings_graph_params.forecastCol,percentile:this.settings_graph_params.percentile,weight:this.settings_graph_params.weight,showFromTo:this.settings_graph_params.showFromTo,showInPlotFitted:this.settings_graph_params.showInPlotFitted},selector:null});break;case\"settings_additional_params\":s.push({objectName:a,properties:{valuesNonNegative:this.settings_additional_params.valuesNonNegative,algModeFast:this.settings_additional_params.algModeFast},selector:null});break;case\"settings_info_params\":s.push({objectName:a,properties:{textSize:this.settings_info_params.textSize,showInfoCriterion:this.settings_info_params.showInfoCriterion,showInfoCumSum:this.settings_info_params.showInfoCumSum,showInfoMethodTBATS:this.settings_info_params.showInfoMethodTBATS},selector:null})}return s},e}();t.Visual=e}(t.PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS||(t.PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS={}))}(t.visual||(t.visual={}))}(t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){!function(e){!function(e){e.PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS={name:\"PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS\",displayName:\"Forecasting\",class:\"Visual\",version:\"1.0.0\",apiVersion:\"1.4.0\",create:function(e){return new t.extensibility.visual.PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS.Visual(e)},custom:!0}}(e.plugins||(e.plugins={}))}(t.visuals||(t.visuals={}))}(powerbi||(powerbi={}));","css":".visual-PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS .rcv_autoScaleImageContainer{position:relative}.visual-PBI_CV_8EDDC07B_EE79_4418_A84C_D73897C0E21F_TBATS .rcv_autoScaleImageContainer .rcv_autoScaleImage{max-width:100%;max-height:100%;position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%);-webkit-transform:translateY(-50%) translateX(-50%)}","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAABiklEQVQ4jWNmYGCQlpb58+f3nz9/GEgETAwMDP5BwVLSMqTqhGomA5g4+ZOpWVnHNDyvmRzNUooa8ZUTIGzSNHNy8yZUTuDk5iVHc0bLXEExKTiXhXid4XnNUooaLz587403x6eZlYOHgYHh948vcBG3iEwDe79Sfz0It3rZmVYGE+ya9YJLvr9/cW3bDAjXxMnfNjitMkifgYGhfd1FFmZGBm4GBqx+ltC0ElbUkzFy45NUZmBgkFLUsA7Nqw0xZGBg6N54iYWZEa4SXTOnoLhecMmltT0Pjq3XDyrh5OZ9du/GxAxniE40xejO1g8qeXJu14vrx15cPyZj6Pb9y2cGBob6led4OFgYGBi+f/1898rp5/dv3r1yBl2zolUQl4DE2aWNEO7FdT3pKkf/vrp+/tGKe1fOPL1/4/2rZ+iezMrNV1ZR5ZNU9m7ZBfEnkQDhZ/2gktv7Fn96fpdkzWpOsQwMDLf2LSZeJ0Izn6TymWUNJOlkgAeYmdB7s4ZaknQW5+eQahkKAADFS3kNJnnJ/wAAAABJRU5ErkJggg=="}}